import parser::*;
import scope::*;
import fmt::{
  StringBuilder,
};

CompilationMode :: enum {
  Default = 0,
  Debug   = 0,
  Release = 1
}

import inst::*;

Emitter :: struct {
  current_scope: *mut Scope,
  registers: List!<(bool, Register)>,
  externs: fmt::StringBuilder,
  code: fmt::StringBuilder,
  sp: u64,
}

impl Emitter {
  new :: fn() -> Emitter {
    return .{
      registers: List!<(bool, Register)>::init(.[
        (false, Register::RBX),
        (false, Register::R10),
        (false, Register::R11),
        (false, Register::R12),
        (false, Register::R13),
        (false, Register::R14),
        (false, Register::R15),
      ]),

    }
  }
  register_take :: fn(*mut self) -> Option!<Register> {
    for *taken, register in self.registers.iter_mut() {
      if *taken 
        then continue;
      *taken = true;
      return Some(register);
    }
    return None();
  }
  register_return :: fn(*mut self, register: Register) {
    for *taken, reg in self.registers.iter_mut() {
      if register == reg 
        then *taken = false;
    }
  }
  free :: fn(*mut self, value: Value) {
    // TODO: free stack as well
    if value is Value::Register(reg) {
      // we dont free rax or rdx because we reserve it for div results
      if reg == Register::RAX || reg == Register::RDX {
        return;
      }
      self.register_return(reg);
    }
  }
}

impl Emitter {
  visit_program :: fn(*mut self, mut program: Program) {
    self.current_scope = new(Scope.{});
    for function in program.functions {
      self.visit_function(function);
    }
    self.current_scope = null;
  }

  visit_block :: fn(*mut self, mut block: Block) {
    old_scope := self.current_scope;
    self.current_scope = block.scope;
    block.scope.parent = Some(old_scope);
    for statement in block.statements {
      self.visit_statement(statement);
    }
    self.current_scope = old_scope;
  }

  visit_function :: fn(*mut self, function: Function) {
    for i, param in function.parameters.enumerate() {
      function.block.scope.insert(param, Value::Param(i as u16));
    }
    self.code.append(function.name);
    self.code.append(":\n");
    self.code.append("push rbp\nmov rbp, rsp\n");
    self.sp = 0;
    self.visit_block(function.block);
    self.code.append("ret\n");
  }

  visit_unary :: fn(*mut self, operand: *mut Expression, operator: TType) -> Value {
    operand_result := self.visit_expression(operand);
    inst::emit_unary("neg", operand_result, &mut self.code, &const "negate");
    return operand_result;
  }

  visit_binary :: fn(*mut self, left: *mut Expression, right: *mut Expression, operator: TType) -> Value {
    right_value := self.visit_expression(right);
    if operator == TType::Assign {
      if left is Expression::Identifier(identifier) {
        alloca := *self.current_scope.get(identifier).unwrap();
        mut comment := fmt::qformat("storing %", (identifier,));
        as_str := comment.as_str();
        inst::emit_binary("mov", alloca, right_value, &mut self.code, &const as_str);
        comment.deinit();
        return Value::Literal(0);
      } else {
        panic("cannot assign to non symbol");
      }
    }
    mut left_value := self.visit_expression(left);
    if operator == TType::Div || operator == TType::Modulo {
      inst::emit_binary("mov", Value::Register(Register::RAX), left_value, &mut self.code, null);
      inst::emit_nullary("cqo", &mut self.code, null)
      self.free(left_value);
      inst::emit_unary(operator.to_inst(), right_value, &mut self.code, null);
      if operator == TType::Div {
        left_value = Value::Register(Register::RAX);
      } else {
        left_value =  Value::Register(Register::RDX);
      }
    } else {
      inst::emit_binary(operator.to_inst(), left_value, right_value, &mut self.code, null);
    }
    self.free(right_value);
    return left_value;
  }

  visit_call :: fn(*mut self, callee: InternedString, args: List!<*mut Expression>) -> Value {
    return .{};
  }

  visit_if :: fn(*mut self, condition: *mut Expression, mut block: Block) {
    #static mut if_id: u64 = 0;
    if_label := fmt::qformat(".if%", (if_id,));
    cont_label := fmt::qformat(".cont%", (if_id,));
    if_id++;

    condition_result := self.visit_expression(condition);

    inst::emit_binary("icmp", condition_result, Value::Literal(0), &mut self.code, &const "if (cond)");
    inst::emit_unary("je", Value::Label(InternedString::new(cont_label)), &mut self.code, &const "if (!cond)");

    self.code.append(if_label);
    self.code.append(":\n");
    self.visit_block(block);
    self.code.append(cont_label);
    self.code.append(":\n");
  }

  visit_extrn :: fn(*mut self, identifier: InternedString) {
    // TODO: this wont work for global variables.
    self.externs.appendf("extern %\n", (identifier.value(),), fmt::FormatOptions::default());
    value := Value::Label(identifier);
    self.current_scope.insert(identifier, value);
  }

  visit_auto :: fn(*mut self, identifier: InternedString) {
    mut comment := fmt::qformat("alloca %", (identifier,));
    as_str := comment.as_str();
    inst::emit_binary("sub", Value::Register(Register::RSP), Value::Literal(8), &mut self.code, &const as_str);
    self.sp += 8;
    value := Value::Stack(self.sp);
    self.current_scope.insert(identifier, value);
  }

  visit_statement :: fn(*mut self, statement: *mut Statement) {
    switch is statement {
      Statement::Extrn(identifier): { self.visit_extrn(identifier); }
      Statement::Auto(identifier): { self.visit_auto(identifier); }
      Statement::Expression(expression): { self.visit_expression(expression); }
      Statement::If(condition, block): { self.visit_if(condition, block); }
      else: { panic("Unhandled statement type"); }
    }
  }

  visit_expression :: fn(*mut self, expression: *mut Expression) -> Value {
    switch is expression {
      // TODO: put literals into a register right away.
      Expression::Literal(integer): {
        val := Value::Register(self.register_take().unwrap());
        inst::emit_binary("mov", val, Value::Literal(integer), &mut self.code, &const "loading literal")
        return val;
      },
      Expression::Identifier(identifier): {
        val := Value::Register(self.register_take().unwrap());
        alloca := *self.current_scope.get(identifier).unwrap();
        mut comment := fmt::qformat("loading %", (identifier,));
        as_str := comment.as_str();
        inst::emit_binary("mov", val, alloca, &mut self.code, &const as_str);
        comment.deinit();
        return val;
      },
      Expression::Unary(operand, operator) => self.visit_unary(operand, operator),
      Expression::Binary(left, right, operator) => self.visit_binary(left, right, operator),
      Expression::Call(callee, args) => self.visit_call(callee, args),
      else: {
        panic("Unhandled expression type");
      }
    }
    return .{};
  }

}