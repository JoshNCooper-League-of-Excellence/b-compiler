import parser::*;
import scope::*;
import fmt::{
  StringBuilder,
};

CompilationMode :: enum {
  Default = 0,
  Debug   = 0,
  Release = 1
}

import inst::*;

Emitter :: struct {
  current_scope: *mut Scope,
  registers: List!<(bool, Register)>,
  bss_section: fmt::StringBuilder,
  code: fmt::StringBuilder,
  sp: u64,
}

impl Emitter {
  register_take :: fn(*mut self) -> Option!<Register> {
    for *taken, register in self.registers.iter_mut() {
      if *taken 
        then continue;
      *taken = true;
      return Some(register);
    }
    return None();
  }
  register_return :: fn(*mut self, register: Register) {
    for *taken, reg in self.registers.iter_mut() {
      if register == reg 
        then *taken = false;
    }
  }
}

impl Emitter {
  visit_program :: fn(*mut self, mut program: Program) {
    self.current_scope = new(Scope.{});
    for function in program.functions {
      self.visit_function(function);
    }
    self.current_scope = null;
  }

  visit_block :: fn(*mut self, block: Block) {
    old_scope := self.current_scope;
    self.current_scope = block.scope;
    block.scope.parent = old_scope;
    for statement in block.statements {
      self.visit_statement(statement);
    }
    self.current_scope = old_scope;
  }

  visit_function :: fn(*mut self, function: Function) {
    for i, param in function.parameters.enumerate() {
      function.block.scope.insert(param, Value::Param(i as u16));
    }
    self.visit_block(function.block);
  }

  visit_unary :: fn(*mut self, operand: *mut Expression, operator: TType) -> Value {
    operand_result := self.visit_expression(operand);
    inst::emit_unary("neg", operand_result, &mut self.code, &const "negate");
    return operand_result;
  }

  visit_binary :: fn(*mut self, left: *mut Expression, right: *mut Expression, operator: TType) -> Value {
    left_value := self.visit_expression(left);
    right_value := self.visit_expression(right);
    inst::emit_binary(operator.to_inst(), left_value, right_value, &mut self.code, null);
    return left_value;
  }

  visit_call :: fn(*mut self, callee: InternedString, args: List!<*mut Expression>) -> Value {
    return .{};
  }

  visit_if :: fn(*mut self, condition: *mut Expression, block: Block) {

  }

  visit_extrn :: fn(*mut self, identifier: InternedString) {

  }

  visit_auto :: fn(*mut self, identifier: InternedString) {
    
  }

  visit_statement :: fn(*mut self, statement: *mut Statement) {
    switch is statement {
      Statement::Extrn(identifier): { self.visit_extrn(identifier); }
      Statement::Auto(identifier): { self.visit_auto(identifier); }
      Statement::Expression(expression): { self.visit_expression(expression); }
      Statement::If(condition, block): { self.visit_if(condition, block); }
      else: { panic("Unhandled statement type"); }
    }
  }

  visit_expression :: fn(*mut self, expression: *mut Expression) -> Value {
    switch is expression {
      Expression::Literal(integer) => Value::Literal(integer),
      Expression::Identifier(identifier) => *self.current_scope.get(identifier).unwrap(),
      Expression::Unary(operand, operator) => self.visit_unary(operand, operator),
      Expression::Binary(left, right, operator) => self.visit_binary(left, right, operator),
      Expression::Call(callee, args) => self.visit_call(callee, args),
      else: {
        panic("Unhandled expression type");
      }
    }
    return .{};
  }

}